//Copyright (C) 2012 Ashley Davis
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated 
//documentation files (the "Software"), to deal in the Software without restriction, including without limitation 
//the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
//and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
//WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#include "HttpServer.h"
#include "DllResourceManager.h"
#include "mongoose.h"

#include <Windows.h>
#include <string.h>
#include <stdio.h>
#include <boost/algorithm/string.hpp>

using std::vector;
using std::string;

//
// Static callback from the HTTP server to serve pages and data.
//
static void* HttpServerCallback(enum mg_event event, struct mg_connection* conn, const struct mg_request_info* request_info) 
{
	HttpServer* httpServer = (HttpServer*)request_info->user_data;
	return httpServer->HttpServerCallback(event, conn, request_info);	
};

HttpServer::HttpServer() :
	httpServerContext(NULL)
{
    const char *options[] = 
    {
        "listening_ports", "8080", 
        "enable_directory_listing", "no",		// Don't allow directories in the file system to be viewed.
        "document_root", "investigo-data",		// Only allow files to be viewed from a specific directory.
        NULL
    };

    httpServerContext = mg_start(::HttpServerCallback, this, options);
}


HttpServer::~HttpServer()
{
    mg_stop(httpServerContext);
}

//
// Instance callback from the HTTP server to serve pages and data.
//
void* HttpServer::HttpServerCallback(enum mg_event event, struct mg_connection* conn, const struct mg_request_info* request_info) 
{
	char buf[1024];
	sprintf(buf, "HTTP event: %d\n", event);
	OutputDebugStringA(buf);

	sprintf(buf, "URI: %s\n", request_info->uri);
	OutputDebugStringA(buf);

	sprintf(buf, "Method: %s\n", request_info->request_method);
	OutputDebugStringA(buf);

	sprintf(buf, "Query: %s\n", request_info->query_string);
	OutputDebugStringA(buf);

	if (event == MG_NEW_REQUEST) 
	{
		UrlCallbackMap::iterator found = urlCallbacks.find(request_info->uri);
		if (found != urlCallbacks.end())
		{
			vector<unsigned char> data;
			string mimeType;
			StringMap queryStringMap;
			ParseQueryString(request_info->query_string, queryStringMap);

			found->second(request_info->uri, queryStringMap, mimeType, data);

			//
			// Serve up a page or data generated by the callback.
			//
			mg_printf(conn, "HTTP/1.1 200 OK\r\n"
				"Content-Type: %s\r\n\r\n",
				mimeType.c_str());

			if (data.size() > 0)
			{
				mg_write(conn, &data[0], data.size());
			}

			return ""; // Content has been served.
		}

		const unsigned char* data = NULL;
		const char* mimeType = NULL;
		int dataSize = 0;
		if (resourceManager.GetResourceData(request_info->uri, &data, &dataSize, &mimeType))
		{
			//
			// Serve up a page or data from DLL embedded resources.
			//
			mg_printf(conn, "HTTP/1.1 200 OK\r\n"
							"Content-Type: %s\r\n\r\n",
				mimeType);

			mg_write(conn, data, dataSize);

			return ""; // Content has been served.
		}

        if (strncmp(request_info->uri, "/test_", 6) == 0 ||
            strncmp(request_info->uri, "test_", 5) == 0)
        {
            //
            // Any URL that is not found and begins with 'test_' is a test file that is 
            // unavailable when the web server is live.
            // Just return a blank document.
            //
            mg_printf(conn, "HTTP/1.1 200 OK\r\n"
                "Content-Type: text/javascript\r\n\r\n");
            return "";
        }
	}

	return NULL; // Allow files to be loaded from the file system, but only from the directory specified in the configuration.
}

//
// Add a callback for an URL.  The callback generates the data returned by the HTTP server.
//
void HttpServer::AddUrlCallback(const char* url, UrlCallback callback)
{
	urlCallbacks[url] = callback;
}

//
// Parse a query string out to a map.
//
void HttpServer::ParseQueryString(const char* queryString, StringMap& queryStringMap)
{
	if (queryString == NULL ||
		queryString[0] == '\0')
	{
		// Nothing to parse.
		return;
	}

	vector<string> strs;
	boost::split(strs, queryString, boost::is_any_of("&"));

	for (int i = 0; i < (int)strs.size(); ++i)
	{
		vector<string> assignment;
		boost::split(assignment, strs[i], boost::is_any_of("="));

		if (assignment.size() == 2)
		{
            boost::replace_all(assignment[1], "%3A", ":");

			queryStringMap[assignment[0]] = assignment[1];
		}
	}
}
